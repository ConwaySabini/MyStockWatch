{"version":3,"sources":["../../server/models/User.js"],"names":["USER_TYPES","CONSUMER","ADMIN","userSchema","mongoose","Schema","_id","type","String","default","userId","firstName","lastName","email","password","timestamps","collection","statics","createUser","pass","bcrypt","hash","create","error","getUserById","id","user","findOne","getUserByUserId","getUsers","find","deleteUserById","deleteOne","getUserByIds","ids","users","$in","getUserByEmail","userEmail","verifyPassword","isPassword","compareSync","model"],"mappings":"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","sourcesContent":["// imports\nimport mongoose from \"mongoose\";\nimport { nanoid } from \"nanoid\";\nimport bcrypt from 'bcrypt';\n\nexport const USER_TYPES = {\n  CONSUMER: \"consumer\",\n  ADMIN: \"admin\",\n};\n\n// Schema for the user model\nconst userSchema = new mongoose.Schema(\n  {\n    _id: {\n      type: String,\n      default: () => nanoid(),\n    },\n    userId: String,\n    firstName: String,\n    lastName: String,\n    type: String,\n    email: String,\n    password: String,\n  },\n  {\n    timestamps: true,\n    collection: \"users\",\n  }\n);\n\n// Creates a new user with the given email, password, firstName, lastName, and type\n// Returns the newly created user\nuserSchema.statics.createUser = async function (firstName, lastName, type, email, pass) {\n  try {\n    // Hash the password with 10 rounds of salting\n    const password = await bcrypt.hash(pass, 10);\n    // create the user\n    return await this.create({ firstName, lastName, type, email, password });\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Get the user by their id and return the found user if they exist\nuserSchema.statics.getUserById = async function (id) {\n  try {\n    const user = await this.findOne({ _id: id });\n    if (!user) throw ({ error: 'No user with this id found' });\n    return user;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Get the user by their userId and return the found user if they exist\nuserSchema.statics.getUserByUserId = async function (userId) {\n  try {\n    const user = await this.findOne({ userId: userId });\n    if (!user) throw ({ error: 'No user with this userId found' });\n    return user;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Get all users in the database and return them\nuserSchema.statics.getUsers = async function () {\n  try {\n    return await this.find();\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Delete a user with the given id and return the result\nuserSchema.statics.deleteUserById = async function (id) {\n  try {\n    return await this.deleteOne({ _id: id });\n  } catch (error) {\n    throw error;\n  }\n}\n\n\n// Get users by their ids and return the found users\nuserSchema.statics.getUserByIds = async function (ids) {\n  try {\n    const users = await this.find({ _id: { $in: ids } });\n    if (!users) throw ({ error: 'No users with these ids were found' });\n    return users;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Get a user with the given email and return the found user if they exist\nuserSchema.statics.getUserByEmail = async function (userEmail) {\n  try {\n    const user = await this.findOne({ \"email\": userEmail });\n    // return null if the user doesn't exist\n    if (!user) return null;\n    return user;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Verify the email and password of the user\nuserSchema.statics.verifyPassword = async function (email, password) {\n  try {\n    // Get hashed password from the database and compare\n    const user = await this.findOne({ \"email\": email });\n    // Throw error if user doesn't exist\n    if (!user) throw ({ error: 'No user with this email' });\n    // Compare the password with the hashed password\n    const isPassword = bcrypt.compareSync(password, user.password);\n    // Throw error if password is incorrect\n    if (!isPassword) throw ({ error: 'Password is incorrect' });\n    return user;\n  } catch (error) {\n    throw error;\n  }\n}\n\nexport default mongoose.model(\"User\", userSchema);\n"],"file":"User.js"}